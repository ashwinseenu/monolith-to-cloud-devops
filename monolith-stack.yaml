AWSTemplateFormatVersion: '2010-09-09'
Description: 'AWS Infra deploying nodejs app: ASG + RDS + ALB (HTTPS/Redirect) + Route53 + ACM + HostedZones + LamdaFunction'

# ==========================================
# 1. PARAMETERS
# ==========================================
Parameters:
  KeyName:
    Description: Existing EC2 KeyPair for SSH access.
    Type: AWS::EC2::KeyPair::KeyName

  GitRepoUrl:
    Description: HTTPS URL of Git repo.
    Type: String
    MinLength: 10

  DBMasterUser:
    Description: Database Master Username.
    Type: String
    Default: admin

  DBMasterPassword:
    Description: Database Master Password (Min 8 chars).
    Type: String
    NoEcho: true
    MinLength: 8

  InstanceType:
    Description: Web Server Instance Type.
    Type: String
    Default: t3.micro
    AllowedValues: [t2.micro, t3.micro, t3.small, t3.medium]
  
  DomainName:
    Description: The domain name for the application (e.g., ashwinseenu.online)
    Type: String

# ==========================================
# 2. RESOURCES
# ==========================================
Resources:
  # --- NETWORK ---
  MonoVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags: [{Key: Name, Value: Mono-VPC}]

  InternetGateway:
    Type: AWS::EC2::InternetGateway

  VPCGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties: {VpcId: !Ref MonoVPC, InternetGatewayId: !Ref InternetGateway}

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties: {VpcId: !Ref MonoVPC}

  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: VPCGatewayAttachment
    Properties: {RouteTableId: !Ref PublicRouteTable, DestinationCidrBlock: 0.0.0.0/0, GatewayId: !Ref InternetGateway}

  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref MonoVPC
      CidrBlock: 10.0.1.0/24
      AvailabilityZone: !Select [0, !GetAZs '']
      MapPublicIpOnLaunch: true

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref MonoVPC
      CidrBlock: 10.0.2.0/24
      AvailabilityZone: !Select [1, !GetAZs '']
      MapPublicIpOnLaunch: true

  Subnet1Route:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties: {SubnetId: !Ref PublicSubnet1, RouteTableId: !Ref PublicRouteTable}
  Subnet2Route:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties: {SubnetId: !Ref PublicSubnet2, RouteTableId: !Ref PublicRouteTable}

  # --- SECURITY GROUPS ---
  ALBSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Public Web Traffic
      VpcId: !Ref MonoVPC
      SecurityGroupIngress: 
        - {IpProtocol: tcp, FromPort: 80, ToPort: 80, CidrIp: 0.0.0.0/0}
        - {IpProtocol: tcp, FromPort: 443, ToPort: 443, CidrIp: 0.0.0.0/0}

  AppSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: ALB and SSH Traffic
      VpcId: !Ref MonoVPC
      SecurityGroupIngress:
        - {IpProtocol: tcp, FromPort: 3000, ToPort: 3000, SourceSecurityGroupId: !Ref ALBSG}
        - {IpProtocol: tcp, FromPort: 22, ToPort: 22, CidrIp: 0.0.0.0/0}

  DBSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Database Access
      VpcId: !Ref MonoVPC
      SecurityGroupIngress: [{IpProtocol: tcp, FromPort: 3306, ToPort: 3306, SourceSecurityGroupId: !Ref AppSG}]

  # --- DNS ---
  HostedZone:
    Type: AWS::Route53::HostedZone
    Properties: 
      Name: !Ref DomainName

  # --- CERTIFICATE MANAGER (ACM) ---
  SSLCertificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Ref DomainName
      SubjectAlternativeNames:
        - !Sub "*.${DomainName}"
      ValidationMethod: DNS
      DomainValidationOptions:
        - DomainName: !Ref DomainName
          HostedZoneId: !Ref HostedZone

  # --- DATABASE ---
  DBSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: RDS Subnets
      SubnetIds: [!Ref PublicSubnet1, !Ref PublicSubnet2]

  RDSInstance:
    Type: AWS::RDS::DBInstance
    Properties:
      Engine: mysql
      EngineVersion: "8.4.3"
      DBInstanceClass: db.t3.micro
      DBInstanceIdentifier: legacy-monolithic-db
      MasterUsername: !Ref DBMasterUser
      MasterUserPassword: !Ref DBMasterPassword
      AllocatedStorage: 20
      StorageType: gp3
      DBSubnetGroupName: !Ref DBSubnetGroup
      VPCSecurityGroups: [!Ref DBSG]
      PubliclyAccessible: false

  # --- LOAD BALANCER ---
  ALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: Mono-ALB
      Scheme: internet-facing
      Subnets: [!Ref PublicSubnet1, !Ref PublicSubnet2]
      SecurityGroups: [!Ref ALBSG]
      Type: application

  ALBListenerHTTP:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref ALB
      Port: 80
      Protocol: HTTP
      DefaultActions:
        - Type: redirect # Redirects traffic to HTTPS Listener
          RedirectConfig:
            Protocol: "HTTPS"
            Port: "443"
            StatusCode: "HTTP_301"

  ALBListenerHTTPS:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref ALB
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref SSLCertificate
      DefaultActions:
        - Type: forward # Forwarding Traffic to TargetGroup
          TargetGroupArn: !Ref ALBTargetGroup

  ALBTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: Mono-TG
      Port: 3000
      Protocol: HTTP
      VpcId: !Ref MonoVPC
      TargetType: instance
      HealthCheckPath: /
      Matcher: {HttpCode: "200"}

  # --- ROUTE 53 RECORDS ---
  RecordSetRoot:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZone
      Name: !Ref DomainName
      Type: A
      AliasTarget:
        HostedZoneId: !GetAtt ALB.CanonicalHostedZoneID
        DNSName: !GetAtt ALB.DNSName

  RecordSetWWW:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZone
      Name: !Sub "www.${DomainName}"
      Type: A
      AliasTarget:
        HostedZoneId: !GetAtt ALB.CanonicalHostedZoneID
        DNSName: !GetAtt ALB.DNSName

  # --- LAUNCH TEMPLATE ---
  AppLaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub ${AWS::StackName}-template
      LaunchTemplateData:
        ImageId: resolve:ssm:/aws/service/canonical/ubuntu/server/22.04/stable/current/amd64/hvm/ebs-gp2/ami-id
        InstanceType: !Ref InstanceType
        KeyName: !Ref KeyName
        NetworkInterfaces:
          - DeviceIndex: 0
            AssociatePublicIpAddress: true
            Groups: [!Ref AppSG]
        
        UserData:
          Fn::Base64: 
            !Sub 
              - |
                #!/bin/bash
                
                # ==================================================
                # PHASE 1: CODE RETRIEVAL & DISTRIBUTION
                # ==================================================
                apt-get update -y
                apt-get install -y git curl

                # Clone Logic
                git clone ${GitUrl} /tmp/temp-repo
                cp -r /tmp/temp-repo/* /home/ubuntu/
                
                mkdir -p /home/ubuntu/app
                if [ -f /tmp/temp-repo/server.js ]; then
                    cp /tmp/temp-repo/server.js /home/ubuntu/app/
                else
                    echo "WARNING: server.js not found in repo"
                fi
                rm -rf /tmp/temp-repo
                chown -R ubuntu:ubuntu /home/ubuntu

                # Write Secrets to .env 
                echo "Configuring Environment..."
                echo "DB_HOST=${RDSEndpoint}" > /home/ubuntu/app/.env
                echo "DB_USER=${DBUser}" >> /home/ubuntu/app/.env
                echo "DB_PASS=${DBPassword}" >> /home/ubuntu/app/.env
                chown -R ubuntu:ubuntu /home/ubuntu/app
                chmod 600 /home/ubuntu/app/.env

                # ==================================================
                # PHASE 2: EXECUTION
                # ==================================================
                # chmod +x /home/ubuntu/set-env.sh
                chmod +x /home/ubuntu/provision.sh
                # /home/ubuntu/set-env.sh
                /home/ubuntu/provision.sh

              - { 
                  RDSEndpoint: !GetAtt RDSInstance.Endpoint.Address,
                  DBUser: !Ref DBMasterUser,
                  DBPassword: !Ref DBMasterPassword,
                  GitUrl: !Ref GitRepoUrl
                }

  # --- AUTO SCALING GROUP (ASG) ---
  AppAutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      AutoScalingGroupName: !Sub ${AWS::StackName}-ASG
      LaunchTemplate:
        LaunchTemplateId: !Ref AppLaunchTemplate
        Version: !GetAtt AppLaunchTemplate.LatestVersionNumber
      MinSize: 2
      MaxSize: 4
      DesiredCapacity: 2
      VPCZoneIdentifier: 
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2
      TargetGroupARNs: 
        - !Ref ALBTargetGroup
      HealthCheckType: ELB
      HealthCheckGracePeriod: 300

  CPUScalingPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AutoScalingGroupName: !Ref AppAutoScalingGroup
      PolicyType: TargetTrackingScaling
      TargetTrackingConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ASGAverageCPUUtilization
        TargetValue: 5.0 # CPU Utilization Target
        DisableScaleIn: false # Allows Scale Down 

# Lambda Initiation while stack deletion process to prevent HostedZone deletion failures
# Lamda - IAM Role Creation
  CleanupLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: {Service: lambda.amazonaws.com}
            Action: sts:AssumeRole
      Policies:
        - PolicyName: Route53Cleanup
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - route53:ListResourceRecordSets
                  - route53:ChangeResourceRecordSets
                  - route53:GetHostedZone
                Resource: !Sub "arn:aws:route53:::hostedzone/${HostedZone}"
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"

  # The Script - Lambda Function
  ZoneCleanupFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt CleanupLambdaRole.Arn
      Runtime: python3.9
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def handler(event, context):
              try:
                  if event['RequestType'] == 'Delete':
                      zone_id = event['ResourceProperties']['HostedZoneId']
                      r53 = boto3.client('route53')
                      
                      # List all records
                      logger.info(f"Listing records for zone: {zone_id}")
                      response = r53.list_resource_record_sets(HostedZoneId=zone_id)
                      records = response['ResourceRecordSets']
                      
                      # Filter out the default SOA and NS records
                      changes = []
                      for record in records:
                          if record['Type'] not in ['SOA', 'NS']:
                              changes.append({
                                  'Action': 'DELETE',
                                  'ResourceRecordSet': record
                              })
                      
                      # Delete the leftovers
                      if changes:
                          logger.info(f"Deleting {len(changes)} records...")
                          r53.change_resource_record_sets(
                              HostedZoneId=zone_id,
                              ChangeBatch={'Changes': changes}
                          )
                      else:
                          logger.info("Zone is already clean.")

                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              except Exception as e:
                  logger.error(f"Error: {str(e)}")
                  # Send SUCCESS anyway even stack DELETE_FAILED
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})

  # The Trigger for Lamda (Custom Resource)
  ZoneCleanupTrigger:
    Type: Custom::Route53Cleanup
    Properties:
      ServiceToken: !GetAtt ZoneCleanupFunction.Arn
      HostedZoneId: !Ref HostedZone

# ==========================================
# 3. OUTPUTS
# ==========================================
Outputs:
  LoadBalancerDNS:
    Description: Application Load Balancer DNS Name
    Value: !GetAtt ALB.DNSName
  
  DomainUrl:
    Description: Secure Application URL
    Value: !Sub "https://${DomainName}"

  Nameservers:
    Description: Nameservers
    Value: !Join [", ", !GetAtt HostedZone.NameServers]
